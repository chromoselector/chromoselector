<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <script src="../libs/jquery-1.8.1.js" type="text/javascript"></script>
    <script src="../color-picker.js" type="text/javascript"></script>
    <script type="text/javascript">
(function (window, $) {
    "use strict";
    window.TESTSUITE(window);
    var canvas = document.createElement('canvas');
    canvas.width = 400;
    canvas.height = 400;
    canvas.style.display = 'block';

    var tempCanvas = $(canvas).clone()//.appendTo('body');

    var self = {
        diameter: 400,
        color: new Color('#f80'),
        tempCanvas: tempCanvas[0],
        triangleRadius: 400 / 2 - 30

    };
    var origin = [self.diameter / 2, self.diameter / 2];
    var rad2deg = (180/Math_PI);

    $(function () {
        $('body').append(tempCanvas);

        self.canvases = [0,$(canvas).clone().appendTo('body')[0]];
        var startTime = new Date();
        test1(self);
        var duration = new Date() - startTime;
        $('body').append(duration+" mS<br/>")
        self.canvases = [0,$(canvas).clone().appendTo('body')[0]];
        startTime = new Date();
        test2(self);
        duration = new Date() - startTime;
        $('body').append(duration+" mS<br/>")
        self.canvases = [0,$(canvas).clone().appendTo('body')[0]];
        startTime = new Date();
        test3(self);
        duration = new Date() - startTime;
        $('body').append(duration+" mS<br/>")
        self.canvases = [0,$(canvas).clone().appendTo('body')[0]];
        startTime = new Date();
        test4(self);
        duration = new Date() - startTime;
        $('body').append(duration+" mS<br/>")
    });

    function limits(points, axis) {
        return {
            start: Math_round(Math_min(points[0][axis] - 2, points[1][axis] - 2, points[2][axis] - 2)),
            end: Math_round(Math_max(points[0][axis] + 2, points[1][axis] + 2, points[2][axis] + 2))
        };
    }

    function test1(self) {
        var hue = self.color.hsl.h;
        var canvas = self.canvases[1];
        var ctx = canvas.getContext("2d");
        var degrees = -Math_PI / 2;
        var points = ColorPicker_getPoints(self, degrees);
        var tempCtx;
        if (! self.ready) {
            var startTime = new Date();
            var maskImageData = ctx.createImageData(self.diameter, self.diameter);
            // triangle limits
            var limits = function (points, axis) {
                return {
                    start: Math_round(Math_min(points[0][axis] - 3, points[1][axis] - 3, points[2][axis] - 3)),
                    end: Math_round(Math_max(points[0][axis] + 3, points[1][axis] + 3, points[2][axis] + 3))
                };
            };
            var limitX = limits(points, 0);
            var limitY = limits(points, 1);
            var i, j;
            // draw
            for (i = points[0][0] - 3; i <= limitX.end; i++) {
                for (j = limitY.start + (1.7*(i-points[0][0]) | 0) - 3; j <= limitY.end; j++) {
                    setPixel(
                        maskImageData,
                        i,
                        j,
                        getLumAlphaColor(points[0], points[1], points[2], [i, j])
                    );
                }
            }
            for (i = limitX.start; i <= points[0][0] - 3; i++) {
                for (j = limitY.start - (1.7*(i-points[0][0]) | 0) - 3; j <= limitY.end; j++) {
                    setPixel(
                        maskImageData,
                        i,
                        j,
                        getLumAlphaColor(points[0], points[1], points[2], [i, j])
                    );
                }
            }

            tempCtx = self.tempCanvas.getContext('2d');
            tempCtx.putImageData(maskImageData, 0, 0);


            var lingrad = tempCtx.createLinearGradient(0,limitY.start,0,limitY.end);
            lingrad.addColorStop(1, 'rgba(0,0,0,0)');
            lingrad.addColorStop(0, 'rgba(0,0,0,255)');
            tempCtx.fillStyle = lingrad;
            tempCtx.globalCompositeOperation = "destination-out";
            tempCtx.fillRect(limitX.start,limitY.start,limitX.end,limitY.end);
            tempCtx.globalCompositeOperation = "source-over";
        }
        degrees = (1 - hue) * Math_PI * 2;
        points = ColorPicker_getPoints(self, degrees);
        // Fill background
        ctx.fillStyle = Color_rgb2hex(
            Color_hsl2rgb({
                h:hue, s:1, l:0.5
            })
        );
        ctx.fillRect(0,0,self.diameter,self.diameter);
        // Copy rotated mask
       /* ctx.save();
        ctx.translate(self.diameter/2, self.diameter/2);
        ctx.rotate(degrees + Math_PI / 2);
        ctx.translate(-self.diameter/2, -self.diameter/2);
        ctx.drawImage(self.tempCanvas, 0, 0);
        ctx.restore();
        // cut out triangle
        ctx.beginPath();
        ctx.moveTo(points[0][0], points[0][1]);
        ctx.lineTo(points[1][0], points[1][1]);
        ctx.lineTo(points[2][0], points[2][1]);
        ctx.closePath();
        ctx.globalCompositeOperation = "destination-in";
        ctx.fillStyle = "rgba(0,0,0,1)";
        ctx.fill();
        // shadow
       /* ctx.beginPath();
        ctx.globalCompositeOperation = "destination-over";
        ctx.moveTo(points[0][0], points[0][1]);
        ctx.lineTo(points[1][0], points[1][1]);
        ctx.lineTo(points[2][0], points[2][1]);
        ctx.closePath();
        ctx.fillStyle = "#000";
        ctx.shadowColor = 'rgba(0,0,0,0.2)';
        ctx.shadowBlur = 5;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.fill();*/
        ctx.globalCompositeOperation = "source-over";
    }

    function test2(self) {
       var hue = self.color.hsl.h;
        var canvas = self.canvases[1];
        var ctx = canvas.getContext("2d");
        var degrees = -Math_PI / 2;
        var points = ColorPicker_getPoints(self, degrees);
        var tempCtx;
        if (! self.ready) {
            var startTime = new Date();
            var maskImageData = ctx.createImageData(self.diameter, self.diameter);
            // triangle limits
            var limits = function (points, axis) {
                return {
                    start: Math_round(Math_min(points[0][axis] - 3, points[1][axis] - 3, points[2][axis] - 3)),
                    end: Math_round(Math_max(points[0][axis] + 3, points[1][axis] + 3, points[2][axis] + 3))
                };
            };
            var limitX = limits(points, 0);
            var limitY = limits(points, 1);
            var i, j;
            // draw
            for (i = points[0][0] - 3; i <= limitX.end; i++) {
                for (j = limitY.start + (1.7*(i-points[0][0]) | 0) - 3; j <= limitY.end; j++) {
                    setPixel(
                        maskImageData,
                        i,
                        j,
                        getLumAlphaColor(points[0], points[1], points[2], [i, j])
                    );
                }
            }
            for (i = limitX.start; i <= points[0][0] - 3; i++) {
                for (j = limitY.start - (1.7*(i-points[0][0]) | 0) - 3; j <= limitY.end; j++) {
                    setPixel(
                        maskImageData,
                        i,
                        j,
                        getLumAlphaColor(points[0], points[1], points[2], [i, j])
                    );
                }
            }

            tempCtx = self.tempCanvas.getContext('2d');
            tempCtx.putImageData(maskImageData, 0, 0);


            var lingrad = tempCtx.createLinearGradient(0,limitY.start,0,limitY.end);
            lingrad.addColorStop(1, 'rgba(0,0,0,0)');
            lingrad.addColorStop(0, 'rgba(0,0,0,255)');
            tempCtx.fillStyle = lingrad;
            tempCtx.globalCompositeOperation = "destination-out";
            tempCtx.fillRect(limitX.start,limitY.start,limitX.end,limitY.end);
            tempCtx.globalCompositeOperation = "source-over";
        }
        degrees = (1 - hue) * Math_PI * 2;
        points = ColorPicker_getPoints(self, degrees);
        // Fill background
        ctx.fillStyle = Color_rgb2hex(
            Color_hsl2rgb({
                h:hue, s:1, l:0.5
            })
        );
        ctx.fillRect(0,0,self.diameter,self.diameter);
        ctx.globalCompositeOperation = "source-over";

                ctx.drawImage(self.tempCanvas, 0, 0);


    }

    function test3(self) {
        var hue = self.color.hsl.h;
        var canvas = self.canvases[1];
        var ctx = canvas.getContext("2d");
        var degrees = -Math_PI / 2;
        var points = ColorPicker_getPoints(self, degrees);
        var tempCtx;
        if (! self.ready) {
            var startTime = new Date();
            var maskImageData = ctx.createImageData(self.diameter, self.diameter);
            // triangle limits
            var limits = function (points, axis) {
                return {
                    start: Math_round(Math_min(points[0][axis] - 3, points[1][axis] - 3, points[2][axis] - 3)),
                    end: Math_round(Math_max(points[0][axis] + 3, points[1][axis] + 3, points[2][axis] + 3))
                };
            };
            var limitX = limits(points, 0);
            var limitY = limits(points, 1);
            var i, j;
            // draw
            for (i = points[0][0] - 3; i <= limitX.end; i++) {
                for (j = limitY.start + (1.7*(i-points[0][0]) | 0) - 3; j <= limitY.end; j++) {
                    setPixel(
                        maskImageData,
                        i,
                        j,
                        getLumAlphaColor(points[0], points[1], points[2], [i, j])
                    );
                }
            }
            for (i = limitX.start; i <= points[0][0] - 3; i++) {
                for (j = limitY.start - (1.7*(i-points[0][0]) | 0) - 3; j <= limitY.end; j++) {
                    setPixel(
                        maskImageData,
                        i,
                        j,
                        getLumAlphaColor(points[0], points[1], points[2], [i, j])
                    );
                }
            }

            tempCtx = self.tempCanvas.getContext('2d');
            tempCtx.putImageData(maskImageData, 0, 0);


            var lingrad = tempCtx.createLinearGradient(0,limitY.start,0,limitY.end);
            lingrad.addColorStop(1, 'rgba(0,0,0,0)');
            lingrad.addColorStop(0, 'rgba(0,0,0,255)');
            tempCtx.fillStyle = lingrad;
            tempCtx.globalCompositeOperation = "destination-out";
            tempCtx.fillRect(limitX.start,limitY.start,limitX.end,limitY.end);
            tempCtx.globalCompositeOperation = "source-over";
        }

        degrees = (1 - hue) * Math_PI * 2;
        points = ColorPicker_getPoints(self, degrees);
        // Fill background
        ctx.fillStyle = Color_rgb2hex(
            Color_hsl2rgb({
                h:hue, s:1, l:0.5
            })
        );
        ctx.fillRect(0,0,self.diameter,self.diameter);
        // Copy rotated mask
        ctx.save();
        ctx.translate(self.diameter/2, self.diameter/2);
        ctx.rotate(degrees + Math_PI / 2);
        ctx.translate(-self.diameter/2, -self.diameter/2);
        ctx.drawImage(self.tempCanvas, 0, 0);
        ctx.restore();
        ctx.globalCompositeOperation = "source-over";
    }

    function test4(self) {
        var hue = self.color.hsl.h;
        var canvas = self.canvases[1];
        var ctx = canvas.getContext("2d");
        var degrees = -Math_PI / 2;
        var points = ColorPicker_getPoints(self, degrees);
        var tempCtx;
        if (! self.ready) {
            var startTime = new Date();
            var maskImageData = ctx.createImageData(self.diameter, self.diameter);
            // triangle limits
            var limits = function (points, axis) {
                return {
                    start: Math_round(Math_min(points[0][axis] - 3, points[1][axis] - 3, points[2][axis] - 3)),
                    end: Math_round(Math_max(points[0][axis] + 3, points[1][axis] + 3, points[2][axis] + 3))
                };
            };
            var limitX = limits(points, 0);
            var limitY = limits(points, 1);
            var i, j;
            // draw
            for (i = points[0][0] - 3; i <= limitX.end; i++) {
                for (j = limitY.start + (1.7*(i-points[0][0]) | 0) - 3; j <= limitY.end; j++) {
                    setPixel(
                        maskImageData,
                        i,
                        j,
                        getLumAlphaColor(points[0], points[1], points[2], [i, j])
                    );
                }
            }
            for (i = limitX.start; i <= points[0][0] - 3; i++) {
                for (j = limitY.start - (1.7*(i-points[0][0]) | 0) - 3; j <= limitY.end; j++) {
                    setPixel(
                        maskImageData,
                        i,
                        j,
                        getLumAlphaColor(points[0], points[1], points[2], [i, j])
                    );
                }
            }

            tempCtx = self.tempCanvas.getContext('2d');
            tempCtx.putImageData(maskImageData, 0, 0);


            var lingrad = tempCtx.createLinearGradient(0,limitY.start,0,limitY.end);
            lingrad.addColorStop(1, 'rgba(0,0,0,0)');
            lingrad.addColorStop(0, 'rgba(0,0,0,255)');
            tempCtx.fillStyle = lingrad;
            tempCtx.globalCompositeOperation = "destination-out";
            tempCtx.fillRect(limitX.start,limitY.start,limitX.end,limitY.end);
            tempCtx.globalCompositeOperation = "source-over";
        }

        degrees = (1 - hue) * Math_PI * 2;
        points = ColorPicker_getPoints(self, degrees);
        // Fill background
        ctx.fillStyle = Color_rgb2hex(
            Color_hsl2rgb({
                h:hue, s:1, l:0.5
            })
        );
        ctx.fillRect(0,0,self.diameter,self.diameter);
        // Copy rotated mask
        ctx.save();
        ctx.translate(self.diameter/2, self.diameter/2);
        ctx.rotate(degrees + Math_PI / 2);
        ctx.translate(-self.diameter/2, -self.diameter/2);
        ctx.drawImage(self.tempCanvas, 0, 0);
        ctx.restore();
        // cut out triangle
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(points[1][0], points[1][1]);
        ctx.lineTo(points[0][0], points[0][1]);
        ctx.lineTo(points[2][0], points[2][1]);
        ctx.lineTo(points[1][0], points[1][1]);
        ctx.lineTo(0, 0);
        ctx.lineTo(0, self.diameter);
        ctx.lineTo(self.diameter, self.diameter);
        ctx.lineTo(self.diameter, 0);
        ctx.lineTo(0, 0);
        ctx.closePath();
        ctx.globalCompositeOperation = "destination-out";
        ctx.fillStyle = "rgba(0,0,0,1)";
        ctx.fill();
    }
})(window, jQuery);
    </script>
    <style type="text/css">
        body {
            margin: 2em;
            background: #adf;
        }
    </style>
</head>
<body>

</body>
</html>
